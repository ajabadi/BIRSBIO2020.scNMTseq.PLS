---
title: "scNMTseq challenge analysis using a PLS-based approach"
author: Al JalalAbadi^[Melbourne Integrative Genomics, The University of Melbourne (al.jal.abadi@gmail.com)]
date: "`r format(Sys.Date(), '%d %b %Y')`"
output: rmarkdown::html_vignette
params:
  drop_lineages: !r c('Visceral_endoderm', 'ExE_ectoderm')
  keep_assays: !r c("rna", "met_genebody", "met_promoter", "met_cgi", "met_p300", "met_CTCF", "met_DHS")
  save_output: no
  data_path: "https://cloudstor.aarnet.edu.au/plus/s/Xzf5vCgAEUVgbfQ/download?path=%2Foutput&files=scnmtseq_gastrulation_mae_826-cells_orderedFeatures.rds"
  umap_params: !r c(run.seed = 42, n_neighbors = 15, n_components = 4, min_dist = 0.1)
  on_my_mac: !r Sys.info()['user'] == 'alabadi'
  not_on_my_mac: !r Sys.info()['user'] != 'alabadi'
vignette: >
  %\VignetteIndexEntry{scNMTseq challenge analysis using a PLS-based approach}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

To Do

* Add kNN

--------

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7
)
```

**Note:** These analyses are (slightly) different from the ones presented in the hackathon in the sense that:

  - The cells used are different (only embryonic cells used)
  - To enhance reproducibility on different machines, `uwot::umap` was used instead of `umap::umap` for dimensionality reduction of RNA data so that python dependencies are reduced
  
--------

Load the required packages:

```{r, eval=params$on_my_mac, include=FALSE}
local.lib <- '../lib'
dir.create(local.lib)
.libPaths(local.lib)
# remotes::install_github('mixOmicsTeam/mixOmics@MultiAssayExperiment', upgrade = 'never')
```

```{r, warning=FALSE, message=FALSE}
library(BIRSBIO2020.scNMTseq.PLS)
library(MultiAssayExperiment)
library(mixOmics)
library(ggplot2)
library(knitr)
library(uwot)
library(nipals)
library(biomaRt)
library(magrittr)
library(reshape2)
library(data.table)
library(MOFA2)
```

```{r, eval=params$save_output, include=params$save_output}
## create directories to save the figures and output data:
if (!dir.exists('figures')) {
  cat('creating "figures" folder ...\n')
  dir.create('figures')
}

if (!dir.exists('savedata')) {
   cat('creating "savedata" folder ...\n')
  dir.create('savedata')
}
```

# Data

Details of the hackathon data and preprocessing steps: https://github.com/BIRSBiointegration/Hackathon/tree/master/scNMT-seq

Load the `MultiAssayExperiment` object:

```{r, eval=params$on_my_mac, include=FALSE}
cat('loading data from Cloudstor ...\n')
gastru.mae <- readRDS('/Users/alabadi/Projects/analysis/R/multiOmics/scNMTseq/BIRSBIO_scNMTseq/output/scnmtseq_gastrulation_mae_826-cells_orderedFeatures-weights.rds')
```

```{r, eval=params$not_on_my_mac}
cat(sprintf('loading data from %s ...\n', params$data_path))
gastru.mae <- readRDS(url(params$data_path))
```

An overview of the data object:

```{r}
gastru.mae
```

## filter extra-embryonic cells

```{r}
cat(sprintf('Dropping cells from lineage(s) %s:\n', paste(sQuote(params$drop_lineages), collapse = ', ')))
cat(sprintf('Retaining assays: %s: \n', paste(sQuote(params$keep_assays), collapse = ', ')))
gastru.mae <- gastru.mae[, !(gastru.mae$lineage10x_2 %in% params$drop_lineages), params$keep_assays]
```

```{r}
gastru.mae
```

Breakdown of the cells in each stage:

```{r}
table(gastru.mae$stage) %>% as.data.frame() %>% set_colnames(c('stage', '# of cells')) %>% kable()
## create a data.frame from cell metadata
coldata <- data.frame(colData(gastru.mae))
```

## Feature detection

Create density plots of the feature detection rate across all cells for all modalities:

```{r}
# get the methylation assays
met_assays <- grep(names(gastru.mae), pattern = '^met', value = TRUE)
# add dimensions to labels for ggplot
dims <- lapply(experiments(gastru.mae[,,met_assays]), dim)
dims <- sapply(dims, function(x) sprintf(' (%s, %s)', x[2], x[1]))
names(met_assays) <- paste0(met_assays, dims) %>% as.list()
met_assays
# calculate the feature detection in a data.frame for methylation assays
coverages <- lapply(met_assays, function(assay_name) {
  mat <- assay(gastru.mae, assay_name)
  NAs <- rowSums(!is.na(mat))/dim(mat)[2]*100
  data.frame(pct_NAs=NAs)
})
# create a long data.frame containing the assay name for plot
coverages <- rbindListWithNames(coverages)
coverages$dataset <- factor(coverages$dataset, levels = unique(coverages$dataset), ordered = TRUE)
```

Genomic contexts vary in level of feature detection rates:

```{r, fig.width=8, fig.asp=0.4, fig.cap="density plots for methylation data show that shorter genomic regions tend to have less feture coverage. Dashed blue line indicates the average across all modalities."}
cov_plot <- ggplot(coverages, aes(x = pct_NAs)) + geom_density(fill = 'lightblue', show.legend = FALSE) +
  geom_vline(aes(xintercept=mean(pct_NAs)),
             color="blue", linetype="dashed", size=0.5) +
  labs(x = '% of cells detecting the feature') + facet_wrap(.~dataset, nrow = 2) +
  theme_bw() + theme(strip.text.x = element_text(size = 10, face = 'bold', color = 'purple'))
  
cov_plot
```

```{r, eval=params$save_output, include=params$save_output}
ggsave(cov_plot, filename = 'figures/covplots.pdf', width = 8, height = 4)
```

# RNA

## UMAP

Here we use `uwot` package for Uniform Manifold Approximation Projection. The original study used the `umap` package with `method = 'umap-learn'` parameter which requires the 'umap-learn' python library and can add complexity to set up on a VM.

```{r}
RNGversion('4.0.1')
set.seed(params$umap_params['run.seed'])
## all params use defaults except for 'n_components' and 'min_dist'
cat(sprintf('running umap on RNA data with parameters: %s ...\n ',
            paste(names(params$umap_params[-1]), ':',
                  params$umap_params[-1], collapse = ', ')))
umap_rna_unsup <- uwot::umap(
  t(assay(gastru.mae, 'rna')),
  n_neighbors = params$umap_params['n_neighbors'],
  n_components = params$umap_params['n_components'],
  min_dist = params$umap_params['min_dist'], ## continuity (min_dist >> 0)-discreteness (min_dist -> 0) trade-off
  metric = "euclidean",
  n_epochs = NULL,
  learning_rate = 1,
  scale = FALSE,
  init = "spectral",
  init_sdev = NULL,
  spread = 1,
  set_op_mix_ratio = 1,
  local_connectivity = 1)
```

```{r, eval=params$save_output, include=params$save_output}
saveRDS(umap_rna_unsup, file = sprintf('savedata/umap-result-ncomp-%s.rds', params$umap_params['n_components']))
# umap_rna_unsup <- readRDS(sprintf('savedata/umap-result-ncomp-%s.rds', params$umap_params['n_components']))
```

Create a data.frame of embeddings:
```{r}
df <- data.frame(umap_rna_unsup)
colnames(df) <- paste0('UMAP_', seq_along(df))
df <- cbind(df, coldata)
```

Create colour palettes for stages and lineages:

```{r}
# col_pallete <- viridisLite::viridis(n = 4)
col_pallete <- c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF")
names(col_pallete) <- c("E4.5", "E5.5", "E6.5", "E7.5")
```


```{r}
## helper function to create both plots coloured by stage
plot_umap_by_stage <- function(df, dims = c(1,2)) {
  axes <- paste0('UMAP_', dims)
  ggplot(df, aes_string(axes[1], axes[2])) + geom_point(aes(col=stage)) +
    theme_classic()+ scale_color_manual(values = col_pallete)
}
```

First two components:

```{r, fig.asp=0.6, fig.cap="UMAP plot shows distinct cell populations corresponding to early-stage, mid-stage, and late-stage cells as well as the within-stage variation for mainly E4.5 and E6.5 which could correspond to different lineages."}
plot_umap_by_stage(df = df, dims = c(1,2))
```


# Integration

## gene id to gene symbol conversion data.frame

Get all the gene names from all modalities:

```{r}
all_features <- sapply(experiments(gastru.mae), rownames) %>% unlist()
all_genes <- grep(pattern = '^ENSMUSG', x = all_features, value = TRUE)
all_genes <- unique(all_genes)
length(all_genes)
```

Get the Ensembl gene name for these gene ids:

```{r}
ensembl <- useMart("ensembl", dataset="mmusculus_gene_ensembl")
mouse_gene_ids  <- all_genes

symbols <- getBM(attributes=c('ensembl_gene_id',
                          'external_gene_name'),
             filters = "ensembl_gene_id",
             values = all_genes,
             mart = ensembl)
symbols <- data.frame(symbols, row.names = 1)
```

```{r, eval=params$save_output, echo=FALSE}
save(symbols, file = 'savedata/all-gene-symbols.RData')
# load('savedata/all-gene-symbols.RData')
```

## PLS integartion of all modalities with feature selection 

```{r}
# data dimensions
lapply(experiments(gastru.mae), dim)
```

```{r}
mmspls <- multimodal_analysis_wrapper(mae = gastru.mae, study_assays = NULL, ncomp = 2, scale = FALSE, design = 'null', lineages = NULL, stages = NULL, DA = NULL, keepX = NULL, save = FALSE)
```

```{r, eval=params$save_output, echo=FALSE}
saveRDS(mmspls, file = 'savedata/MultiModalSparsePLS-All.rds')
# mmspls <- readRDS('savedata/MultiModalSparsePLS-All.rds')
```

```{r}
plotIndiv_wrapper <- function(pls_obj, coldata, col_cell = 'stage', legend.title = 'Stage', comp = c(1,2), ...) {
  ## order coldata cells based on matching cells in pls modalities
  coldata <- coldata[rownames(pls_obj$X[[1]]),]
  cell_class <- coldata[,col_cell]  ## col factor for cells
  cell_class <- factor(cell_class)  
  suppressWarnings({
    plotIndiv(pls_obj, pch = 16, comp = comp,group = cell_class, legend = TRUE, legend.title = legend.title, size.subtitle = 10, cex=0.8, ...)
  })
}
```

## score plots

Colored by stage:

```{r, fig.width=8}
plotIndiv_wrapper(pls_obj = mmspls, coldata = coldata, col_cell = 'stage', legend.title = 'Stage', comp = c(1,2), subtitle = names(mmspls$X), col.per.group = col_pallete)
```

```{r, eval=params$save_output, echo=FALSE}
ggsave(filename = 'figures/plotIndiv-MultiModalSparsePLS-stage.pdf', width = 8, height = 6)
```

# Concordancy with RNA

Here we calculate the average correlation between components from gene expression and different methylome modalities:
```{r}
concordancy <- function(pls_obj, comp = 1) {
  
  cor_with_y <- sapply(pls_obj$variates[-1], function(x_variates) {
    y_variates <- pls_obj$variates[[1]]
    y_variates <- y_variates[, comp, drop = FALSE]
    
    avg_cor <- mean(diag(cor(y_variates, x_variates)))
    avg_cor
  }) 
  cor_with_y <- cor_with_y %>% sort(decreasing = TRUE)
  cor_with_y <- cor_with_y %>% as.data.frame() %>% set_colnames(c('concordancy'))
  cor_with_y %>% round(digits = 2) %>% t() %>%  kable() %>% print()
  
  cor_with_y$modality <- factor(rownames(cor_with_y), levels = rownames(cor_with_y), ordered = TRUE)
  ggplot(cor_with_y, aes(x = modality, y = concordancy)) + geom_col(fill = "#35B779FF") + theme_classic() +
    labs(y = sprintf('Correlation with RNA (comp %s) ', paste(comp, collapse = ', ')), x = '') + ylim(c(0, 1)) + theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=1))
}
```

```{r}
concordancy(pls_obj = mmspls, comp = c(1, 2))
```

```
