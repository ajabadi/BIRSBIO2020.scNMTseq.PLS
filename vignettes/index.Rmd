---
title: "scNMTseq challenge analysis using a PLS-based approach"
author: Al JalalAbadi^[Melbourne Integrative Genomics, The University of Melbourne (al.jal.abadi@gmail.com)]
date: "`r format(Sys.Date(), '%d %b %Y')`"
output: rmarkdown::html_vignette
params:
  ## setup params
  on_my_mac: !r Sys.info()['user'] == 'alabadi'
  save_output: false
  local_data: false
  mini_run: false
  # mini_run: !r Sys.info()['user'] == 'alabadi'
  matching_rna_for_umap: false
  ## run params
  drop_lineages: !r c('Primitive_endoderm','Visceral_endoderm', 'ExE_ectoderm')
  umap_params: !r c(run.seed = 42, n_neighbors = 15, n_components = 2, min_dist = 0.55)
vignette: >
  %\VignetteIndexEntry{scNMTseq challenge analysis using a PLS-based approach}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


--------

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(collapse = TRUE, 
                      comment = "#>", 
                      fig.width = 8, 
                      cache = FALSE)
```

**Note:** These analyses are different from the ones presented in the hackathon due to updated preprocessing if data in order to harmonize the analyses for publication. For original analyses see https://github.com/ajabadi/scNMT_seq_gastrulation.
  
--------

Load the required packages:

```{r, eval=params$on_my_mac, include=FALSE}
sapply(list.files('../R', full.names = TRUE), source)
local.lib <- '../lib'
dir.create(local.lib)
.libPaths(local.lib)
## uncomment this if you are not building the vignette along with the package
# remotes::install_github('mixOmicsTeam/mixOmics@MultiAssayExperiment', upgrade = 'never')
```

```{r load packages, warning=FALSE, message=FALSE}
library(BIRSBIO2020.scNMTseq.PLS)
library(MultiAssayExperiment)
library(scater)
library(scran)
library(mixOmics)
library(ggplot2)
library(magrittr)
library(reshape2)
library(uwot)
```

```{r, eval=params$save_output, include=params$save_output}
## create directories to save the figures and output data:
if (!dir.exists('figures')) {
  cat('creating "figures" folder ...\n')
  dir.create('figures')
}

if (!dir.exists('savedata')) {
   cat('creating "savedata" folder ...\n')
  dir.create('savedata')
}
```

# Data

Details of the hackathon data and preprocessing steps: https://github.com/BIRSBiointegration/Hackathon/tree/master/scNMT-seq

Load the `MultiAssayExperiment` object from Cloudstor:
```{r, eval=!params$mini_run}
cat('loading data from Cloudstor ...\n')
gastru.mae_path <- url('https://cloudstor.aarnet.edu.au/plus/s/jsW7nh4YwThw8Q5/download')
```

```{r, eval=params$on_my_mac & !params$mini_run, include=FALSE}
cat('loading data from local folder ...\n')
gastru.mae_path <- 'savedata/scnmtseq_gastrulation_mae-sce.rds'
```

```{r, eval=params$on_my_mac & params$mini_run, include=FALSE}
cat('loading mini data from local folder ...\n')
gastru.mae_path <- 'savedata/mini.gastru.mae.rds'
```

```{r load data}
gastru.mae <- readRDS(gastru.mae_path)
```

<!-- ```{r, eval=!params$on_my_mac} -->
<!-- cat(sprintf('loading the following assays using SingleCellMultiModal package: %s\n', paste(params$keep_assays, collapse = ', '))) -->
<!-- gastru.mae <- scNMT(dataType = 'mouse_gastrulation', modes = params$keep_assays, dry.run = FALSE, verbose = FALSE) -->
<!-- ``` -->

## Filter MAE object

```{r}
## subset RNA expression and DNA methylation modalities
keep_assays <- grep("rna|met",names(assays(gastru.mae)))
gastru.mae <- gastru.mae[,,keep_assays]
## remove putative extraembryonic cells
cat(sprintf('dropping lineages %s\n', paste(params$drop_lineages, collapse = ', ')))
gastru.mae <- gastru.mae[,!(gastru.mae$lineage %in% params$drop_lineages),]
## keep cells which pass RNA QC
gastru.mae <- gastru.mae[,gastru.mae$pass_rnaQC==TRUE,]
## Keep full rna SCE for UMAP
rna.sce <- gastru.mae@ExperimentList$rna
## keep cells that also pass QC for DNA methylation
gastru.mae <- gastru.mae[,gastru.mae$pass_metQC==TRUE,]
## rna SCE for cells passing met and rna QC
rna.sce.matching <- gastru.mae@ExperimentList$rna
```

Replace the rna SCE with logcounts in MAE object as the integration wrapper requires matrices in assays:

```{r}
gastru.mae@ExperimentList
## replace SCE with logcounts
gastru.mae@ExperimentList$rna <- logcounts(gastru.mae@ExperimentList$rna)
```

Overview of assays:

```{r}
get_pct_missing <- function(arr) {
  round(100*sum(is.na(arr))/prod(dim(arr)))
}

df <- lapply(experiments(gastru.mae), function(w)
     {
     c(
       'N (# cells)' = dim(w)[2],
       'P (# features)' = dim(w)[1],
       '% data missing' = get_pct_missing(w)
     )
     })
df <- data.frame(df)
kable(t(df), align = 'l')
```

Breakdown of the number of cells in each stage:

```{r, warning=FALSE}
table(gastru.mae$stage) %>% as.data.frame() %>% t() %>% set_rownames(c('stage', '# of cells')) %>% kable()
## create a data.frame from cell metadata
coldata <- data.frame(colData(gastru.mae))
```

## Feature detection

Create density plots of the feature detection rate across all cells for all modalities:

```{r, message=FALSE}
# get the methylation assays
met_assays <- grep(names(gastru.mae), pattern = '^met', value = TRUE)
# add dimensions to labels for ggplot
dims <- lapply(experiments(gastru.mae[,,met_assays]), dim)
dims <- sapply(dims, function(x) sprintf(' (%s, %s)', x[2], x[1]))
names(met_assays) <- paste0(met_assays, dims) %>% as.list()
# calculate the feature detection in a data.frame for methylation assays
coverages <- lapply(met_assays, function(assay_name) {
  mat <- assay(gastru.mae, assay_name)
  NAs <- rowSums(!is.na(mat))/dim(mat)[2]*100
  data.frame(pct_NAs=NAs)
})
# create a long data.frame containing the assay name for plot
coverages <- rbindListWithNames(coverages)
coverages$dataset <- factor(coverages$dataset, levels = unique(coverages$dataset), ordered = TRUE)
```

Genomic contexts vary in level of feature detection rates:

```{r, fig.width=8, fig.asp=0.4}
cov_plot <- ggplot(coverages, aes(x = pct_NAs)) + geom_density(fill = 'lightblue', show.legend = FALSE) +
  geom_vline(aes(xintercept=mean(pct_NAs)),
             color="blue", linetype="dashed", size=0.5) +
  labs(x = '% of cells detecting the feature') + facet_wrap(.~dataset, nrow = 2) +
  theme_bw() + theme(strip.text.x = element_text(size = 10, face = 'bold', color = 'purple'))
  
cov_plot
```
Density plots for methylation data show that shorter genomic regions tend to have less feature coverage. Dashed blue line indicates the average across all modalities.

```{r, eval=params$save_output, include=params$save_output}
ggsave(cov_plot, filename = 'figures/covplots.pdf', width = 8, height = 4)
```

# RNA


```{r}
# Create colour palettes for stages:
# col_pallete <-dput( viridisLite::viridis(n = 4) )
col_pallete <- c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF")
names(col_pallete) <- c("E4.5", "E5.5", "E6.5", "E7.5")

## helper function to create UMAP plots coloured by stage
plot_umap_by_stage <- function(df, dims = c(1,2)) {
  axes <- paste0('UMAP_', dims)
  ggplot(df, aes_string(axes[1], axes[2])) + geom_point(aes(col=stage)) +
    theme_classic()+ scale_color_manual(values = col_pallete) + labs(col = 'Stage')
}
```

## UMAP projection all of RNA cells

Select highly variable genes after accounting for technical variation:

```{r}
decomp <- modelGeneVar(rna.sce)
## filter by mean expression and significance of biological variation signal
hvgs <- rownames(decomp)[decomp$p.value<0.01 & decomp$mean > 0.01]
length(hvgs)
```

Run PCA and then UMAP using PCs:

```{r}
npcs <- 15
## PCA first: retrieve npcs PCs
rna.sce <- runPCA(rna.sce,  ncomponents = npcs, subset_row=hvgs)

## UMAP parameters used:
cat(sprintf('Running UMAP with parameters %s\n', paste(params$umap_params, collapse = ', ')))

## run UMAP
set.seed(params$umap_params['run.seed'])
rna.sce <- runUMAP(rna.sce, dimred="PCA", 
                   ncomponents = params$umap_params['n_components'], 
                   n_neighbors = params$umap_params['n_neighbors'], 
                   min_dist = params$umap_params['min_dist'])
```

data.frame of embeddings with cell metadata:

```{r}
# data.frame of embeddings with cell metadata
df <-  data.frame(reducedDim(rna.sce,"UMAP"))
colnames(df) <- paste0('UMAP_', seq_along(df))
df <- cbind(df, colData(rna.sce))
```

Plot the first two UMAP components:

```{r, fig.asp=0.7}
plot_umap_by_stage(df = df, dims = c(1,2))
```

UMAP plot shows distinct cell populations corresponding to early-stage, mid-stage, and late-stage cells as well as the within-stage variation for mainly E4.5 and E6.5 which could correspond to different lineages.

## UMAP projection all matching RNA cells used in integration

Select highly variable genes after accounting for technical variation:

```{r}
decomp <- modelGeneVar(rna.sce.matching)
## filter by mean expression and significance of biological variation signal
hvgs <- rownames(decomp)[decomp$p.value<0.01 & decomp$mean > 0.01]
length(hvgs)
```

Run PCA and then UMAP using PCs:

```{r}
npcs <- 15
## PCA first: retrieve npcs PCs
rna.sce <- runPCA(rna.sce.matching,  ncomponents = npcs, subset_row=hvgs)

## UMAP parameters used:
params$umap_params

## run UMAP
set.seed(params$umap_params['run.seed'])
rna.sce.matching <- runUMAP(rna.sce.matching, dimred="PCA", 
                   ncomponents = params$umap_params['n_components'], 
                   n_neighbors = params$umap_params['n_neighbors'], 
                   min_dist = params$umap_params['min_dist'])
```

data.frame of embeddings with cell metadata:

```{r}
# data.frame of embeddings with cell metadata
df.matching <-  data.frame(reducedDim(rna.sce.matching,"UMAP"))
colnames(df.matching) <- paste0('UMAP_', seq_along(df.matching))
df.matching <- cbind(df.matching, colData(rna.sce.matching))
```

Plot the first two UMAP components:

```{r, fig.asp=0.7}
plot_umap_by_stage(df = df.matching, dims = c(1,2))
```



# Integration

<!-- ## gene id to gene symbol conversion data.frame -->

<!-- Here we create a reference data.frame to convert Ensembl gene ids to gene symbols for GSEA. -->

<!-- Get all the gene names from all modalities: -->

<!-- ```{r} -->
<!-- all_features <- sapply(experiments(gastru.mae), rownames) %>% unlist() -->
<!-- all_genes <- grep(pattern = '^ENSMUSG', x = all_features, value = TRUE) -->
<!-- all_genes <- unique(all_genes) -->
<!-- length(all_genes) -->
<!-- ``` -->

<!-- Get the Ensembl gene name for these gene ids: -->

<!-- ```{r} -->
<!-- ensembl <- useMart("ensembl", dataset="mmusculus_gene_ensembl") -->
<!-- mouse_gene_ids  <- all_genes -->

<!-- symbols <- getBM(attributes=c('ensembl_gene_id', -->
<!--                               'external_gene_name'), -->
<!--                  filters = "ensembl_gene_id", -->
<!--                  values = all_genes, -->
<!--                  mart = ensembl) -->
<!-- symbols <- data.frame(symbols, row.names = 1) -->
<!-- ``` -->

<!-- ```{r, eval=params$save_output, echo=FALSE} -->
<!-- save(symbols, file = 'savedata/all-gene-symbols.RData') -->
<!-- # load('savedata/all-gene-symbols.RData') -->
<!-- ``` -->

## PLS

data dimensions overview:

```{r}
# data dimensions
lapply(experiments(gastru.mae), dim)
```

integration of all modalities with feature selection:

```{r}
## number of components
ncomp <- 2
## feature scaling
scale <- TRUE
```

<!-- ```{r, eval=params$save_output, echo=params$save_output} -->
<!-- pls_output_name <- sprintf('multimodal_spls-ncomp_%s-scale_.rds', ncomp, scale) -->
<!-- ``` -->

Here we select for 50 features on each component in `multimodal_sPLS_wrapper`:

```{r run pls}
cat(sprintf('Running PLS with %s components performing variable selection\n', ncomp))
st <- system.time({
  mmspls <-
    multimodal_sPLS_wrapper(mae = gastru.mae, study_assays = NULL,
                            ncomp = ncomp, scale = TRUE, design = 'null', lineages = NULL,
                            stages = NULL, DA = NULL, keepX = NULL, save = FALSE)
})['elapsed']
st <- round(st/60, 1)

cat('\nPLS run finished. Runtime: ', st, 'min\n')
```

```{r, eval=params$save_output, echo=params$save_output}
saveRDS(mmspls, file = 'savedata/MultiModalSparsePLS-All.rds')
# mmspls <- readRDS('savedata/MultiModalSparsePLS-All.rds')
```

```{r}
plotIndiv_wrapper <- function(pls_obj, coldata, col_cell = 'stage', legend.title = 'Stage', comp = c(1,2), ...) {
  ## order coldata cells based on matching cells in pls modalities
  coldata <- coldata[rownames(pls_obj$X[[1]]),]
  cell_class <- coldata[,col_cell]  ## col factor for cells
  cell_class <- factor(cell_class)
  suppressWarnings({
    plotIndiv(pls_obj, pch = 16, comp = comp,group = cell_class, legend = TRUE, legend.title = legend.title, size.subtitle = 10, cex=0.8, ...)
  })
}
```

## score plots

Colored by stage:

```{r, fig.width=8, fig.height=8}
plotIndiv_wrapper(pls_obj = mmspls, coldata = coldata, col_cell = 'stage', legend.title = 'Stage', comp = c(1,2), subtitle = names(mmspls$X), col.per.group = col_pallete)
```

```{r, eval=params$save_output, echo=FALSE}
ggsave(filename = 'figures/plotIndiv-MultiModalSparsePLS-stage.pdf', width = 8, height = 6)
```

# concordance with RNA

Here we calculate the correlations between components from gene expression and different methylome modalities:

```{r}
## For a pls object which includes pls cell embeddings from a computed latent space
## where covariance with rna is maximal, calculate the correlation b/w rna embeddings
## and those of a given modality's (per component and average) as a measure of concordant variation with rna
concordance <- function(pls_obj, comp = 1) {
  
  ## correlation of components with RNA components
  cor_with_y <- sapply(pls_obj$variates[-1], function(x_variates) {
    y_variates <- pls_obj$variates[[1]]
    y_variates <- y_variates[, comp, drop = FALSE]
    cor <- cor(y_variates, x_variates)
    cor <- diag(cor)
    names(cor) <- paste0('Component ', comp)
    cor['mean'] <- mean(cor)
    cor <- round(cor, 2)
    cor
  })
  print(kable(cor_with_y))
  ## make a long data.frame
  cor_with_y <- cor_with_y %>% as.data.frame() %>% t() %>% 
    reshape2::melt(id.vars = 1:3) %>% 
    set_colnames(c('Modality', 'Component', 'Concordance'))
  ## print concordance measures for each componet and the average:
  # sapply(unique(as.character(cor_with_y$Component)), function(z){
  #   cat('#> Component:', z )
  #   dplyr::filter(cor_with_y, Component == z)[,c('Modality', 'Concordance')] %>% 
  #     kable() 
  # })

  ggplot(cor_with_y, aes(x = Modality, y = Concordance)) + geom_col(aes(fill = Component), position = 'dodge2') + theme_classic() +
    labs(y = sprintf('Correlation with RNA (comp %s) ', paste(comp, collapse = ', ')), x = '', fill = '') + ylim(c(0, 1)) + theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=1))
}
```

```{r}
concordance(pls_obj = mmspls, comp = c(1, 2))
```


